### Вопросы для размышления:
1. Что происходит, когда два потока пытаются одновременно изменить переменную?
2. Почему результат без синхронизации изменяется при каждом запуске программы?

```csharp
public class ThreadSynchronizationShould
{
    // Общая переменная 
    private int _sharedResource;
    // Объект-заглушка для синхронизации
    private readonly object _lockObject = new object();

    private void IncrementResource(bool isLocked)
    {
        for (int i = 0; i < 100000; i++)
        {
            if (isLocked)
                lock (_lockObject) _sharedResource++;
            else
                _sharedResource++;
        }
    }

    [Theory]
    [InlineData(true)]
    [InlineData(false)]
    public void VerifySharedResource_WhenSynchronizedOrNot(bool isLocked)
    {
        // Инициализация общей переменной перед каждым тестом
        _sharedResource = 0;
        
        // Создаем три потока, которые будут инкрементировать общую переменную
        var thread1 = new Thread(() => IncrementResource(isLocked));
        var thread2 = new Thread(() => IncrementResource(isLocked));
        var thread3 = new Thread(() => IncrementResource(isLocked));
        
        // Запускаем потоки
        thread1.Start();
        thread2.Start();
        thread3.Start();

        // Ожидаем завершения потоков
        thread1.Join();
        thread2.Join();
        thread3.Join();

        if (isLocked) 
            _sharedResource.Should().Be(300000); 
        else 
            _sharedResource.Should().NotBe(300000);
    }
```

#### Ответ на 1 вопрос
Когда два (или более) потока одновременно пытаются изменить одну и ту же переменную без использования механизмов синхронизации, возникает ситуация, называемая гонкой данных.

Вот что происходит "за кулисами":

Каждый поток читает текущее значение переменной, а затем увеличивает это значение. Однако, поскольку потоки выполняются параллельно, они могут читать одно и то же начальное значение и изменять его одновременно.
В итоге, операция инкремента (увеличения переменной) становится некорректной, и некоторые из операций могут "теряться", так как результат одного потока может быть перезаписан результатом другого.
Пример:

- Поток 1 прочитал значение переменной _sharedResource, допустим, оно равно 100.
- Поток 2 одновременно прочитал то же самое значение 100.
- Поток 1 увеличивает значение до 101 и записывает его обратно в переменную.
- Поток 2 также увеличивает значение до 101 (хотя, на самом деле, оно уже должно было быть 102), и перезаписывает результат.

В итоге итоговое значение переменной будет 101 вместо 102, что нарушает логику программы.

#### Ответ на 2 вопрос
Результат без синхронизации изменяется при каждом запуске программы из-за непредсказуемого порядка выполнения потоков. Это связано с тем, что операционная система не гарантирует, что один поток выполнит свою работу до другого. Потоки выполняются параллельно и могут быть прерваны в любой момент.

Вот что происходит:

- В один запуск программы один поток может быть приостановлен операционной системой, чтобы другой поток получил процессорное время. В другой запуск оба потока могут выполняться почти одновременно. Это меняет порядок доступа к переменной.
- Без синхронизации результат зависит от того, как потоки конкурируют за доступ к общему ресурсу. Один поток может "обгонять" другой и завершать свою работу раньше, или оба могут пытаться обновить значение переменной одновременно.

Таким образом, результат инкрементации переменной _sharedResource может сильно отличаться при каждом запуске программы, что является признаком гонки данных. Без синхронизации программа становится непредсказуемой и ненадежной.

#### Подытожим:
- Гонки данных происходят, когда несколько потоков одновременно пытаются изменить одну и ту же переменную без синхронизации. Это приводит к тому, что один поток может перезаписать результат другого.
- Результат без синхронизации меняется при каждом запуске, потому что порядок выполнения потоков не гарантируется. Это приводит к тому, что переменная может быть изменена неоднократно и некорректно.
Эти проблемы решаются с помощью синхронизации (_lock_, _Monitor_, _Mutex_), которая гарантирует, что потоки не будут одновременно изменять общую переменную.

Надеюсь, ответы помогли лучше понять проблемы многопоточности. Если есть еще вопросы — спрашивай!